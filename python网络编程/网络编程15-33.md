# 网络编程15-33

1. TCP

1.1 三次握手，数据传输，四次挥手

- syn：发起请求链接
- ack：回复
- fin：发起断开请求

![15](F:\python_learn\python网络编程\pic\15.png)

1.2 传输消息（可靠）

- 每一个client端发送一个消息后server端都会回复一个消息
- 发送过程可能出现网络抖动而出现消息丢失，没有收到回复信息就重发
- 回复过程可能会出现网络抖动而消息丢失，这时client再次发送，但是server已经收到，这时会将消息丢弃并重新回复一条消息

![16](F:\python_learn\python网络编程\pic\16.png)

1.3 tcp与udp区别

- tcp能传的信息长度几乎是无限制的
- udp是有限制的，与数据传递设备的设置有关系

![17](F:\python_learn\python网络编程\pic\17.png)![18](F:\python_learn\python网络编程\pic\18.png)

------

2. OSI五层模型

2.1 传输过程

![19](F:\python_learn\python网络编程\pic\19.png)

2.2 五层对应的协议和设备

![20](F:\python_learn\python网络编程\pic\20.png)

-----

3. socket套接字

3.1 什么是socket

![21](F:\python_learn\python网络编程\pic\21.png)![22](F:\python_learn\python网络编程\pic\22.png)

----

4. 程序编写

---

5. tcp粘包问题

5.1 粘包问题

- 合包机制：网络延迟，可能会照成两条信息变成一条信息
- 拆包机制：发送的文件过大时，对文件进行拆分，可能会导致在os还在收的时候，server就来收消息了，这时11，12可能还在传输的路上，所以可能出现丢失

![25](F:\python_learn\python网络编程\pic\25.png)

5.2 图解

![26](F:\python_learn\python网络编程\pic\26.png)

5.3 粘包的解决方法

- python   struct模块(这个模块可以将任意数转成4字节，同时也可以解析回来)

```python 
import struct

ret = struct.pack('i', 5)
print(ret)
print(struct.unpack('i', ret))
```

5.4 大文件传输

![27](F:\python_learn\python网络编程\pic\27.png)

---

6. 阻塞、非阻塞

6.1 实现并发

![28](F:\python_learn\python网络编程\pic\28.png)

```python 
sk.setblocking(False)

accept()  没有阻塞，等别人来连接，而是一直运行的。

耗费cpu资源，做了很多无用功
```

---



